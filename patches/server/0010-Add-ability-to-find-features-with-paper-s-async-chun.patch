From b9ea639d5f7d06726db75881d1a92d2778c9975c Mon Sep 17 00:00:00 2001
From: Phoenix616 <mail@moep.tv>
Date: Wed, 27 Nov 2019 19:07:21 +0100
Subject: [PATCH] Add ability to find features with paper's async chunks

This implements World#findNearestMapFeatureAsync method and adds a
config option to use the async search when creating treasure maps
instead of blocking the main thread with loading and generating chunks.

This has the slight downside that the items might break if interacted
with before the async search is finished. That should normally not occur,
especially on pre-generated worlds.
---
 .../de/minebench/origami/OrigamiConfig.java   |  8 ++
 .../net/minecraft/server/ChunkGenerator.java  |  8 ++
 .../minecraft/server/ChunkProviderFlat.java   |  9 +++
 .../net/minecraft/server/ItemWorldMap.java    | 25 +++++-
 .../LootItemFunctionExplorationMap.java       | 19 ++++-
 .../minecraft/server/StructureGenerator.java  | 76 +++++++++++++++++++
 .../net/minecraft/server/VillagerTrades.java  | 21 ++++-
 src/main/java/net/minecraft/server/World.java | 13 ++++
 .../java/net/minecraft/server/WorldMap.java   | 12 +++
 .../net/minecraft/server/WorldServer.java     | 13 ++++
 .../org/bukkit/craftbukkit/CraftWorld.java    | 12 +++
 11 files changed, 211 insertions(+), 5 deletions(-)

diff --git a/src/main/java/de/minebench/origami/OrigamiConfig.java b/src/main/java/de/minebench/origami/OrigamiConfig.java
index 63097cc0..76de2d1c 100644
--- a/src/main/java/de/minebench/origami/OrigamiConfig.java
+++ b/src/main/java/de/minebench/origami/OrigamiConfig.java
@@ -178,6 +178,14 @@ public final class OrigamiConfig {
         private void onlyGetGeneratedFeatures() {
             onlyFindGeneratedFeatures = getBoolean("only-find-generated-features", onlyFindGeneratedFeatures);
         }
+
+        public boolean asyncTreasureMaps = false;
+        private void asyncTreasureMaps() {
+            asyncTreasureMaps = getBoolean("async-treasure-maps", asyncTreasureMaps);
+            if (asyncTreasureMaps) {
+                Bukkit.getLogger().info("Async treasure map generation is enabled");
+            }
+        }
     }
 
     public static boolean teleportingOfVehiclesWithPassenger = true;
diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java
index 701b214b..4a27d987 100644
--- a/src/main/java/net/minecraft/server/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/server/ChunkGenerator.java
@@ -73,6 +73,14 @@ public abstract class ChunkGenerator<C extends GeneratorSettingsDefault> {
         return structuregenerator != null ? structuregenerator.getNearestGeneratedFeature(world, this, blockposition, i, flag) : null;
     }
 
+    // Origami start - async feature search. adapted logic from findNearestMapFeature
+    public void findNearestMapFeatureAsync(World world, String s, BlockPosition blockposition, int i, boolean flag, java.util.function.Consumer<BlockPosition> onComplete) {
+        StructureGenerator<?> structuregenerator = (StructureGenerator) WorldGenerator.aP.get(s.toLowerCase(Locale.ROOT));
+
+        if (structuregenerator != null) structuregenerator.getNearestGeneratedFeatureAsync(world, this, blockposition, i, flag, onComplete);
+    }
+    // Origami end
+
     public void addDecorations(RegionLimitedWorldAccess regionlimitedworldaccess) {
         int i = regionlimitedworldaccess.a();
         int j = regionlimitedworldaccess.b();
diff --git a/src/main/java/net/minecraft/server/ChunkProviderFlat.java b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
index 04834399..a7c03135 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderFlat.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
@@ -169,6 +169,15 @@ public class ChunkProviderFlat extends ChunkGenerator<GeneratorSettingsFlat> {
         return !((GeneratorSettingsFlat) this.settings).w().keySet().contains(s.toLowerCase(Locale.ROOT)) ? null : super.findNearestMapFeature(world, s, blockposition, i, flag);
     }
 
+    // Origami start - async feature search. adapted logic from findNearestMapFeature
+    @Override
+    public void findNearestMapFeatureAsync(World world, String s, BlockPosition blockposition, int i, boolean flag, java.util.function.Consumer<BlockPosition> onComplete) {
+        if (this.settings.w().keySet().contains(s.toLowerCase(Locale.ROOT))) {
+            super.findNearestMapFeatureAsync(world, s, blockposition, i, flag, onComplete);
+        }
+    }
+    // Origami end
+
     class a extends BiomeBase {
 
         protected a(WorldGenSurfaceComposite worldgensurfacecomposite, BiomeBase.Precipitation biomebase_precipitation, BiomeBase.Geography biomebase_geography, float f, float f1, float f2, float f3, int i, int j, String s) {
diff --git a/src/main/java/net/minecraft/server/ItemWorldMap.java b/src/main/java/net/minecraft/server/ItemWorldMap.java
index cf9efcf1..5e65f52a 100644
--- a/src/main/java/net/minecraft/server/ItemWorldMap.java
+++ b/src/main/java/net/minecraft/server/ItemWorldMap.java
@@ -47,12 +47,31 @@ public class ItemWorldMap extends ItemWorldMapBase {
     }
 
     private static WorldMap a(ItemStack itemstack, World world, int i, int j, int k, boolean flag, boolean flag1, DimensionManager dimensionmanager) {
+        // Origami start - OBFHELPER and split in multiple, public methods
+        return initializeMap(itemstack, world, i, j, k, flag, flag1, dimensionmanager);
+    }
+
+    private static WorldMap initializeMap(ItemStack itemstack, World world, int i, int j, int k, boolean flag, boolean flag1, DimensionManager dimensionmanager) {
+        WorldMap worldmap = newWorldMap(world);
+        worldmap.setup(i, j, k, flag, flag1, dimensionmanager);
+        worldmap = addToItem(itemstack, worldmap);
+        return callInitializeEvent(worldmap);
+    }
+
+    public static WorldMap newWorldMap(World world) {
         int l = world.getWorldMapCount();
         WorldMap worldmap = new WorldMap(a(l));
-
-        worldmap.a(i, j, k, flag, flag1, dimensionmanager);
         world.a(worldmap);
-        itemstack.getOrCreateTag().setInt("map", l);
+        return worldmap;
+    }
+
+    public static WorldMap addToItem(ItemStack itemstack, WorldMap worldmap) {
+        itemstack.getOrCreateTag().setInt("map", worldmap.mapId);
+        return worldmap;
+    }
+
+    public static WorldMap callInitializeEvent(WorldMap worldmap) {
+        // Origami end
 
         // CraftBukkit start
         MapInitializeEvent event = new MapInitializeEvent(worldmap.mapView);
diff --git a/src/main/java/net/minecraft/server/LootItemFunctionExplorationMap.java b/src/main/java/net/minecraft/server/LootItemFunctionExplorationMap.java
index 99b0101e..f73b6580 100644
--- a/src/main/java/net/minecraft/server/LootItemFunctionExplorationMap.java
+++ b/src/main/java/net/minecraft/server/LootItemFunctionExplorationMap.java
@@ -42,6 +42,23 @@ public class LootItemFunctionExplorationMap extends LootItemFunctionConditional
 
             if (blockposition != null) {
                 WorldServer worldserver = loottableinfo.d();
+                // Origami start - Async explorer maps
+                if (worldserver.origamiConfig.asyncTreasureMaps) {
+                    ItemStack itemstack1 = new ItemStack(Items.FILLED_MAP);
+                    WorldMap worldMap = ItemWorldMap.newWorldMap(worldserver);
+                    ItemWorldMap.addToItem(itemstack1, worldMap);
+                    itemstack1.a((new ChatMessage("filled_map." + this.d.toLowerCase(Locale.ROOT), new Object[0])));
+                    worldserver.findNearestMapFeatureAsync(this.d, blockposition, this.g, this.h, blockposition1 -> {
+                        if (blockposition1 != null) {
+                            worldMap.setup(blockposition1.getX(), blockposition1.getZ(), this.f, true, true, worldserver.worldProvider.getDimensionManager());
+
+                            ItemWorldMap.applySepiaFilter(worldserver, itemstack1);
+                            worldMap.addDecoration(itemstack1, blockposition1, "+", this.e);
+                        }
+                    });
+                    return itemstack1;
+                }
+                // Origami end
                 BlockPosition blockposition1 = worldserver.a(this.d, blockposition, this.g, this.h);
 
                 if (blockposition1 != null) {
@@ -69,7 +86,7 @@ public class LootItemFunctionExplorationMap extends LootItemFunctionConditional
         }
 
         public void a(JsonObject jsonobject, LootItemFunctionExplorationMap lootitemfunctionexplorationmap, JsonSerializationContext jsonserializationcontext) {
-            super.a(jsonobject, (LootItemFunctionConditional) lootitemfunctionexplorationmap, jsonserializationcontext);
+            super.a(jsonobject, lootitemfunctionexplorationmap, jsonserializationcontext); // Origami - decompile fix
             if (!lootitemfunctionexplorationmap.d.equals("Buried_Treasure")) {
                 jsonobject.add("destination", jsonserializationcontext.serialize(lootitemfunctionexplorationmap.d));
             }
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
index 59a8759b..78080aa7 100644
--- a/src/main/java/net/minecraft/server/StructureGenerator.java
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -3,9 +3,12 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.Dynamic;
 import it.unimi.dsi.fastutil.longs.LongIterator;
+
+import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -144,6 +147,79 @@ public abstract class StructureGenerator<C extends WorldGenFeatureConfiguration>
         }
     }
 
+    // Origami start - async feature search. adapted logic from getNearestGeneratedFeature
+    public void getNearestGeneratedFeatureAsync(World world, ChunkGenerator<? extends GeneratorSettingsDefault> chunkgenerator, BlockPosition blockposition, int i, boolean flag, java.util.function.Consumer<BlockPosition> onComplete) {
+        if (!chunkgenerator.getWorldChunkManager().a(this)) {
+            onComplete.accept(null);
+        } else {
+            int j = blockposition.getX() >> 4;
+            int k = blockposition.getZ() >> 4;
+            SeededRandom seededrandom = new SeededRandom();
+
+            java.util.Deque<ChunkCoordIntPair> chunksToCheck = new java.util.ArrayDeque<>();
+
+            for (int l = 0; l <= i; l++) {
+                int i1 = -l;
+
+                while (true) {
+                    if (i1 <= l) {
+                        boolean flag1 = i1 == -l || i1 == l;
+
+                        for (int j1 = -l; j1 <= l; ++j1) {
+                            boolean flag2 = j1 == -l || j1 == l;
+
+                            if (flag1 || flag2) {
+                                ChunkCoordIntPair chunkcoordintpair = this.a(chunkgenerator, seededrandom, j, k, i1, j1);
+                                if (!world.getWorldBorder().isChunkInBounds(chunkcoordintpair.x, chunkcoordintpair.z)) { continue; } // Paper
+                                chunksToCheck.add(chunkcoordintpair);
+                                if (l == 0) {
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (l != 0) {
+                            ++i1;
+                            continue;
+                        }
+                    }
+                    break;
+                }
+            }
+
+            checkForFeature(world, chunksToCheck, flag, onComplete);
+        }
+    }
+
+    private void checkForFeature(World world, Deque<ChunkCoordIntPair> chunksToCheck, boolean flag, Consumer<BlockPosition> onComplete) {
+        ChunkCoordIntPair chunkcoordintpair = chunksToCheck.pollFirst();
+        if (chunkcoordintpair == null) {
+            onComplete.accept(null);
+            return;
+        }
+
+        ((ChunkProviderServer) world.getChunkProvider()).getChunkAtAsynchronously(chunkcoordintpair.x, chunkcoordintpair.z, !world.origamiConfig.onlyFindGeneratedFeatures, chunk -> {
+            if (chunk != null) {
+                StructureStart structurestart = chunk.a(this.b());
+
+                if (structurestart != null && structurestart.e()) {
+                    if (flag && structurestart.h()) {
+                        structurestart.i();
+                        onComplete.accept(structurestart.a());
+                        return;
+                    }
+
+                    if (!flag) {
+                        onComplete.accept(structurestart.a());
+                        return;
+                    }
+                }
+            }
+            checkForFeature(world, chunksToCheck, flag, onComplete);
+        });
+    }
+    // Origami end
+
     private List<StructureStart> a(GeneratorAccess generatoraccess, int i, int j) {
         List<StructureStart> list = Lists.newArrayList();
         IChunkAccess ichunkaccess = generatoraccess.getChunkAt(i, j, ChunkStatus.STRUCTURE_REFERENCES);
diff --git a/src/main/java/net/minecraft/server/VillagerTrades.java b/src/main/java/net/minecraft/server/VillagerTrades.java
index 99374fe2..0cf1b5cb 100644
--- a/src/main/java/net/minecraft/server/VillagerTrades.java
+++ b/src/main/java/net/minecraft/server/VillagerTrades.java
@@ -5,7 +5,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import java.util.HashMap;
+
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -90,6 +90,25 @@ public class VillagerTrades {
         public MerchantRecipe a(Entity entity, Random random) {
             World world = entity.world;
             if (!world.paperConfig.enableTreasureMaps) return null; //Paper
+
+            // Origami start - Async explorer maps
+            if (world.origamiConfig.asyncTreasureMaps) {
+                ItemStack itemstack = new ItemStack(Items.FILLED_MAP);
+                WorldMap worldMap = ItemWorldMap.newWorldMap(world);
+                ItemWorldMap.addToItem(itemstack, worldMap);
+                itemstack.a((new ChatMessage("filled_map." + this.b.toLowerCase(Locale.ROOT), new Object[0])));
+                world.findNearestMapFeatureAsync(this.b, new BlockPosition(entity), 100, !world.paperConfig.treasureMapsAlreadyDiscovered, blockposition -> {
+                    if (blockposition != null) {
+                        worldMap.setup(blockposition.getX(), blockposition.getZ(), (byte) 2, true, true, world.worldProvider.getDimensionManager());
+
+                        ItemWorldMap.applySepiaFilter(world, itemstack);
+                        worldMap.addDecoration(itemstack, blockposition, "+", this.c);
+                    }
+                });
+                return new MerchantRecipe(new ItemStack(Items.EMERALD, this.a), new ItemStack(Items.COMPASS), itemstack, this.d, this.e, 0.2F);
+            }
+            // Origami end
+
             BlockPosition blockposition = world.a(this.b, new BlockPosition(entity), 100, !world.paperConfig.treasureMapsAlreadyDiscovered); //Paper
 
             if (blockposition != null) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 00b2e892..f1cade23 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1609,9 +1609,22 @@ public abstract class World implements IIBlockAccess, GeneratorAccess, AutoClose
 
     @Nullable
     public BlockPosition a(String s, BlockPosition blockposition, int i, boolean flag) {
+        // Origami start - OBFHELPER
+        return this.findNearestMapFeature(s, blockposition, i, flag);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(String s, BlockPosition blockposition, int i, boolean flag) {
+        // Origami end
         return null;
     }
 
+    // Origami start - async feature search. adapted logic from findNearestMapFeature
+    public void findNearestMapFeatureAsync(String s, BlockPosition blockposition, int i, boolean flag, java.util.function.Consumer<BlockPosition> onComplete) {
+        onComplete.accept(null);
+    }
+    // Origami end
+
     @Override
     public WorldProvider getWorldProvider() {
         return this.worldProvider;
diff --git a/src/main/java/net/minecraft/server/WorldMap.java b/src/main/java/net/minecraft/server/WorldMap.java
index 090d3dbd..1861bf1a 100644
--- a/src/main/java/net/minecraft/server/WorldMap.java
+++ b/src/main/java/net/minecraft/server/WorldMap.java
@@ -18,6 +18,7 @@ import org.bukkit.craftbukkit.util.CraftChatMessage;
 
 public class WorldMap extends PersistentBase {
 
+    public final int mapId; // Origami - store int id
     public int centerX;
     public int centerZ;
     public DimensionManager map;
@@ -41,6 +42,7 @@ public class WorldMap extends PersistentBase {
 
     public WorldMap(String s) {
         super(s);
+        this.mapId = Integer.parseInt(s.substring("map_".length())); // Origami - store int id
         // CraftBukkit start
         mapView = new CraftMapView(this);
         server = (CraftServer) org.bukkit.Bukkit.getServer();
@@ -48,6 +50,7 @@ public class WorldMap extends PersistentBase {
         // CraftBukkit end
     }
 
+    public void setup(int i, int j, int k, boolean flag, boolean flag1, DimensionManager dimensionmanager) { this.a(i, j, k, flag, flag1, dimensionmanager); } // Origami - OBFHELPER
     public void a(int i, int j, int k, boolean flag, boolean flag1, DimensionManager dimensionmanager) {
         this.scale = (byte) k;
         this.a((double) i, (double) j, this.scale);
@@ -278,6 +281,15 @@ public class WorldMap extends PersistentBase {
 
     }
 
+    // Origami start - Async explorer maps, this forward ot the decorateMap method and duplicates some of the code from the method below
+    public void addDecoration(ItemStack itemstack, BlockPosition blockposition, String s, MapIcon.Type mapicon_type) {
+        decorateMap(itemstack, blockposition, s, mapicon_type);
+        if (!decorations.containsKey(s)) {
+            a(mapicon_type, null, s, blockposition.getX(), blockposition.getY(), 180.0D, null);
+        }
+    }
+    // Origami end
+
     private void a(MapIcon.Type mapicon_type, @Nullable GeneratorAccess generatoraccess, String s, double d0, double d1, double d2, @Nullable IChatBaseComponent ichatbasecomponent) {
         int i = 1 << this.scale;
         float f = (float) (d0 - (double) this.centerX) / (float) i;
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 5b18f4bd..f42463d9 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1644,9 +1644,22 @@ public class WorldServer extends World {
     @Nullable
     @Override
     public BlockPosition a(String s, BlockPosition blockposition, int i, boolean flag) {
+        // Origami start - OBFHELPER
+        return this.findNearestMapFeature(s, blockposition, i, flag);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(String s, BlockPosition blockposition, int i, boolean flag) {
+        // Origami end
         return this.getChunkProvider().getChunkGenerator().findNearestMapFeature(this, s, blockposition, i, flag);
     }
 
+    // Origami start - async feature search. adapted logic from findNearestMapFeature
+    public void findNearestMapFeatureAsync(String s, BlockPosition blockposition, int i, boolean flag, java.util.function.Consumer<BlockPosition> onComplete) {
+        this.getChunkProvider().getChunkGenerator().findNearestMapFeatureAsync(this, s, blockposition, i, flag, onComplete);
+    }
+    // Origami end
+
     @Override
     public CraftingManager getCraftingManager() {
         return this.server.getCraftingManager();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index f33d9c8b..d5ba1379 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2334,6 +2334,18 @@ public class CraftWorld implements World {
         return (nearest == null) ? null : new Location(this, nearest.getX(), nearest.getY(), nearest.getZ());
     }
 
+    // Origami start - async feature search. adapted logic from findNearestMapFeature
+    @Override
+    public CompletableFuture<Location> locateNearestStructureAsync(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
+        BlockPosition originPos = new BlockPosition(origin.getX(), origin.getY(), origin.getZ());
+        CompletableFuture<Location> ret = new CompletableFuture<>();
+        getHandle().getChunkProvider().getChunkGenerator().findNearestMapFeatureAsync(getHandle(), structureType.getName(), originPos, radius, findUnexplored, nearest -> {
+            ret.complete((nearest == null) ? null : new Location(this, nearest.getX(), nearest.getY(), nearest.getZ()));
+        });
+        return ret;
+    }
+    // Origami end
+
     @Override
     public Raid locateNearestRaid(Location location, int radius) {
         Validate.notNull(location, "Location cannot be null");
-- 
2.18.0.windows.1

