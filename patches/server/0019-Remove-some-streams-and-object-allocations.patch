From 416e95d92ed02ef4087cf999f6051bfc4071ad09 Mon Sep 17 00:00:00 2001
From: Phoenix616 <mail@moep.tv>
Date: Thu, 30 Jan 2020 21:50:40 +0100
Subject: [PATCH] Remove some streams and object allocations

Partially based on a patch in Spottedleaf's Paper fork
---
 .../java/net/minecraft/server/Behavior.java    | 18 ++++++++++++------
 .../minecraft/server/BehaviorController.java   |  4 ++--
 .../java/net/minecraft/server/ChunkMap.java    | 14 ++++++++------
 .../net/minecraft/server/PathfinderNormal.java |  4 +++-
 .../java/net/minecraft/server/PlayerMap.java   |  2 +-
 .../net/minecraft/server/TileEntityHopper.java |  8 +++++++-
 6 files changed, 33 insertions(+), 17 deletions(-)

diff --git a/src/main/java/net/minecraft/server/Behavior.java b/src/main/java/net/minecraft/server/Behavior.java
index ae1d901e57..8d2f63052f 100644
--- a/src/main/java/net/minecraft/server/Behavior.java
+++ b/src/main/java/net/minecraft/server/Behavior.java
@@ -38,10 +38,12 @@ public abstract class Behavior<E extends EntityLiving> {
         // Origami end
     }
 
+    public Behavior.Status getStatus() { return a();} // Origami - OBFHELPER
     public Behavior.Status a() {
         return this.b;
     }
 
+    public final void attemptStart(WorldServer worldserver, E entity, long time) { b(worldserver, entity, time); } // Origami - OBFHELPER
     public final boolean b(WorldServer worldserver, E e0, long i) {
         // Origami start - configurable behavior tick rates
         int tickRate = worldserver.origamiConfig.getTickRate(RATE_TYPE, configKey, e0.getMinecraftKey().getKey(), -1);
@@ -63,6 +65,7 @@ public abstract class Behavior<E extends EntityLiving> {
 
     protected void a(WorldServer worldserver, E e0, long i) {}
 
+    public final void runOrStop(WorldServer worldserver, E entity, long time) { c(worldserver, entity, time); } // Origami - OBFHELPER
     public final void c(WorldServer worldserver, E e0, long i) {
         if (!this.a(i) && this.g(worldserver, e0, i)) {
             this.d(worldserver, e0, i);
@@ -74,6 +77,7 @@ public abstract class Behavior<E extends EntityLiving> {
 
     protected void d(WorldServer worldserver, E e0, long i) {}
 
+    public final void stop(WorldServer worldserver, E entity, long time) { e(worldserver, entity, time); } // Origami - OBFHELPER
     public final void e(WorldServer worldserver, E e0, long i) {
         this.b = Behavior.Status.STOPPED;
         this.f(worldserver, e0, i);
@@ -98,12 +102,14 @@ public abstract class Behavior<E extends EntityLiving> {
     }
 
     private boolean a(E e0) {
-        return this.a.entrySet().stream().allMatch((entry) -> {
-            MemoryModuleType<?> memorymoduletype = (MemoryModuleType) entry.getKey();
-            MemoryStatus memorystatus = (MemoryStatus) entry.getValue();
-
-            return e0.getBehaviorController().a(memorymoduletype, memorystatus);
-        });
+        // Origami start - remove streams
+        for (Entry<MemoryModuleType<?>, MemoryStatus> entry : this.a.entrySet()) {
+            if (!e0.getBehaviorController().a(entry.getKey(), entry.getValue())) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     public static enum Status {
diff --git a/src/main/java/net/minecraft/server/BehaviorController.java b/src/main/java/net/minecraft/server/BehaviorController.java
index 396b64ea0f..4904eb8386 100644
--- a/src/main/java/net/minecraft/server/BehaviorController.java
+++ b/src/main/java/net/minecraft/server/BehaviorController.java
@@ -23,11 +23,11 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
 
     private final Map<MemoryModuleType<?>, Optional<?>> memories = Maps.newHashMap();
     private final Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap();
-    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap();
+    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap(); private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> getGoals() { return c; }; // Origami - OBFHELPER
     private Schedule schedule;
     private final Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> e;
     private Set<Activity> f;
-    private final Set<Activity> g;
+    private final Set<Activity> g; private final Set<Activity> getActiveActivities() { return g; } // Origami - OBFHELPER
     private Activity h;
     private long i;
 
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e7..8069e494f7 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        // Origami start - remove allocation of ChunkCoordIntPair
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        // Origami end
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        // Origami start - remove allocation of ChunkCoordIntPair
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        // Origami end
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 4240ca81cb..36fef7f70c 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -443,8 +443,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition CACHED_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); // Origami - don't allocate a new BlockPosition each time
+
     protected static PathType c(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition = CACHED_BLOCKPOSITION.setValues(i, j, k); // Origami - don't allocate a new BlockPosition each time
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerMap.java b/src/main/java/net/minecraft/server/PlayerMap.java
index f386c4e997..442ef443be 100644
--- a/src/main/java/net/minecraft/server/PlayerMap.java
+++ b/src/main/java/net/minecraft/server/PlayerMap.java
@@ -6,7 +6,7 @@ import java.util.stream.Stream;
 
 public final class PlayerMap {
 
-    private final Object2BooleanMap<EntityPlayer> a = new Object2BooleanOpenHashMap();
+    public final Object2BooleanMap<EntityPlayer> a = new Object2BooleanOpenHashMap(); // Origami - make public
 
     public PlayerMap() {}
 
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index c755faed4f..8118d53179 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -377,7 +377,13 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     private static IntStream a(IInventory iinventory, EnumDirection enumdirection) {
-        return iinventory instanceof IWorldInventory ? IntStream.of(((IWorldInventory) iinventory).getSlotsForFace(enumdirection)) : IntStream.range(0, iinventory.getSize());
+        // Origami start - remove streams
+        return IntStream.of(getSlots(iinventory, enumdirection));
+    }
+
+    private static int[] getSlots(IInventory iinventory, EnumDirection enumdirection) {
+        return iinventory instanceof IWorldInventory ? ((IWorldInventory) iinventory).getSlotsForFace(enumdirection) : IntStream.range(0, iinventory.getSize()).toArray();
+        // Origami end
     }
 
     private static boolean allMatch(IInventory iinventory, EnumDirection enumdirection, java.util.function.BiPredicate<ItemStack, Integer> test) {
-- 
2.25.1.windows.1

