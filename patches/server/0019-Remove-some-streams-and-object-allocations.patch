From 705452be9412c2bc52db5db42456edc310fa12ce Mon Sep 17 00:00:00 2001
From: Phoenix616 <mail@moep.tv>
Date: Thu, 30 Jan 2020 21:50:40 +0100
Subject: [PATCH] Remove some streams and object allocations

Partially based on a patch in Spottedleaf's Paper fork
---
 .../java/net/minecraft/server/Behavior.java   |   4 +
 .../minecraft/server/BehaviorController.java  |  56 ++++++----
 .../java/net/minecraft/server/ChunkMap.java   |  14 ++-
 .../net/minecraft/server/PairedQueue.java     |  19 +++-
 .../server/PathfinderGoalSelector.java        | 104 ++++++++++--------
 .../minecraft/server/PathfinderNormal.java    |   4 +-
 .../net/minecraft/server/PlayerChunkMap.java  |  18 ++-
 .../java/net/minecraft/server/PlayerMap.java  |   2 +-
 .../minecraft/server/TileEntityHopper.java    |  45 ++++++--
 .../minecraft/server/TileEntityLootable.java  |   9 +-
 10 files changed, 185 insertions(+), 90 deletions(-)

diff --git a/src/main/java/net/minecraft/server/Behavior.java b/src/main/java/net/minecraft/server/Behavior.java
index 640dd0d5f..5bd814eef 100644
--- a/src/main/java/net/minecraft/server/Behavior.java
+++ b/src/main/java/net/minecraft/server/Behavior.java
@@ -38,10 +38,12 @@ public abstract class Behavior<E extends EntityLiving> {
         // Origami end
     }
 
+    public Behavior.Status getStatus() { return a();} // Origami - OBFHELPER
     public Behavior.Status a() {
         return this.b;
     }
 
+    public final void attemptStart(WorldServer worldserver, E entity, long time) { b(worldserver, entity, time); } // Origami - OBFHELPER
     public final boolean b(WorldServer worldserver, E e0, long i) {
         if (this.a(e0) && this.a(worldserver, e0)) {
             this.b = Behavior.Status.RUNNING;
@@ -57,6 +59,7 @@ public abstract class Behavior<E extends EntityLiving> {
 
     protected void a(WorldServer worldserver, E e0, long i) {}
 
+    public final void runOrStop(WorldServer worldserver, E entity, long time) { c(worldserver, entity, time); } // Origami - OBFHELPER
     public final void c(WorldServer worldserver, E e0, long i) {
         if (!this.a(i) && this.g(worldserver, e0, i)) {
             this.d(worldserver, e0, i);
@@ -68,6 +71,7 @@ public abstract class Behavior<E extends EntityLiving> {
 
     protected void d(WorldServer worldserver, E e0, long i) {}
 
+    public final void stop(WorldServer worldserver, E entity, long time) { e(worldserver, entity, time); } // Origami - OBFHELPER
     public final void e(WorldServer worldserver, E e0, long i) {
         this.b = Behavior.Status.STOPPED;
         this.f(worldserver, e0, i);
diff --git a/src/main/java/net/minecraft/server/BehaviorController.java b/src/main/java/net/minecraft/server/BehaviorController.java
index a1883eba6..938690153 100644
--- a/src/main/java/net/minecraft/server/BehaviorController.java
+++ b/src/main/java/net/minecraft/server/BehaviorController.java
@@ -23,11 +23,11 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
 
     private final Map<MemoryModuleType<?>, Optional<?>> memories = Maps.newHashMap();
     private final Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap();
-    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap();
+    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap(); private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> getGoals() { return c; }; // Origami - OBFHELPER
     private Schedule schedule;
     private final Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> e;
     private Set<Activity> f;
-    private final Set<Activity> g;
+    private final Set<Activity> g; private final Set<Activity> getActiveActivities() { return g; } // Origami - OBFHELPER
     private Activity h;
     private long i;
 
@@ -69,7 +69,7 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
     }
 
     private <T, U> void a(MemoryModuleType<U> memorymoduletype, Dynamic<T> dynamic) {
-        this.setMemory(memorymoduletype, ((Function) memorymoduletype.getSerializer().orElseThrow(RuntimeException::new)).apply(dynamic));
+        this.setMemory(memorymoduletype, memorymoduletype.getSerializer().orElseThrow(RuntimeException::new).apply(dynamic)); // Origami - decompile fixes
     }
 
     public <U> void removeMemory(MemoryModuleType<U> memorymoduletype) {
@@ -113,6 +113,20 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
         this.f = set;
     }
 
+    // Origami start - remove streams
+    private void applyToRunningBehaviour(java.util.function.Consumer<Behavior<? super E>> consumer) {
+        for (Map<Activity, Set<Behavior<? super E>>> value : this.getGoals().values()) {
+            for (Set<Behavior<? super E>> behaviors : value.values()) {
+                for (Behavior<? super E> behavior : behaviors) {
+                    if (behavior.getStatus() == Behavior.Status.RUNNING) {
+                        consumer.accept(behavior);
+                    }
+                }
+            }
+        }
+    }
+    // Origami end
+
     @Deprecated
     public Stream<Behavior<? super E>> d() {
         return this.c.values().stream().flatMap((map) -> {
@@ -170,7 +184,7 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
 
         this.memories.forEach((memorymoduletype, optional) -> {
             optional.ifPresent((object) -> {
-                Optional optional1 = (Optional) behaviorcontroller.memories.put(memorymoduletype, Optional.of(object));
+                behaviorcontroller.memories.put(memorymoduletype, Optional.of(object)); // Origami - Decompile fixes
             });
         });
         return behaviorcontroller;
@@ -185,14 +199,12 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
     public void b(WorldServer worldserver, E e0) {
         long i = e0.world.getTime();
 
-        this.d().forEach((behavior) -> {
-            behavior.e(worldserver, e0, i);
-        });
+        applyToRunningBehaviour(behavior -> behavior.stop(worldserver, e0, i)); // Origami - remove streams
     }
 
     @Override
     public <T> T a(DynamicOps<T> dynamicops) {
-        T t0 = dynamicops.createMap((Map) this.memories.entrySet().stream().filter((entry) -> {
+        T t0 = dynamicops.createMap(this.memories.entrySet().stream().filter((entry) -> { // Origami - decompile fixes
             return ((MemoryModuleType) entry.getKey()).getSerializer().isPresent() && ((Optional) entry.getValue()).isPresent();
         }).map((entry) -> {
             return Pair.of(dynamicops.createString(IRegistry.MEMORY_MODULE_TYPE.getKey(entry.getKey()).toString()), ((MinecraftSerializable) ((Optional) entry.getValue()).get()).a(dynamicops));
@@ -210,27 +222,29 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
     private void d(WorldServer worldserver, E e0) {
         long i = worldserver.getTime();
 
-        this.c.values().stream().flatMap((map) -> {
-            return map.entrySet().stream();
-        }).filter((entry) -> {
-            return this.g.contains(entry.getKey());
-        }).map(Entry::getValue).flatMap(Collection::stream).filter((behavior) -> {
-            return behavior.a() == Behavior.Status.STOPPED;
-        }).forEach((behavior) -> {
-            behavior.b(worldserver, e0, i);
-        });
+        // Origami start - remove streams
+        for (Map<Activity, Set<Behavior<? super E>>> value : this.getGoals().values()) {
+            for (Entry<Activity, Set<Behavior<? super E>>> entry : value.entrySet()) {
+                if (this.getActiveActivities().contains(entry.getKey())) {
+                    for (Behavior<? super E> behavior : entry.getValue()) {
+                        if (behavior.getStatus() == Behavior.Status.STOPPED) {
+                            behavior.attemptStart(worldserver, e0, i);
+                        }
+                    }
+                }
+            }
+        }
+        // Origami end
     }
 
     private void e(WorldServer worldserver, E e0) {
         long i = worldserver.getTime();
 
-        this.d().forEach((behavior) -> {
-            behavior.c(worldserver, e0, i);
-        });
+        applyToRunningBehaviour(behavior -> behavior.runOrStop(worldserver, e0, i)); // Origami - remove streams
     }
 
     private boolean d(Activity activity) {
-        return ((Set) this.e.get(activity)).stream().allMatch((pair) -> {
+        return this.e.get(activity).stream().allMatch((pair) -> { // Origami - decompile fixes
             MemoryModuleType<?> memorymoduletype = (MemoryModuleType) pair.getFirst();
             MemoryStatus memorystatus = (MemoryStatus) pair.getSecond();
 
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e..8069e494f 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        // Origami start - remove allocation of ChunkCoordIntPair
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        // Origami end
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        // Origami start - remove allocation of ChunkCoordIntPair
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        // Origami end
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/PairedQueue.java b/src/main/java/net/minecraft/server/PairedQueue.java
index 85bb22e4b..4e2a6591a 100644
--- a/src/main/java/net/minecraft/server/PairedQueue.java
+++ b/src/main/java/net/minecraft/server/PairedQueue.java
@@ -23,9 +23,12 @@ public interface PairedQueue<T, F> {
         private final List<Queue<Runnable>> a;
 
         public a(int i) {
-            this.a = (List) IntStream.range(0, i).mapToObj((j) -> {
-                return Queues.newConcurrentLinkedQueue();
-            }).collect(Collectors.toList());
+            // Origami start - remove streams
+            this.a = new java.util.ArrayList<>(i);
+            for (int j = 0; j < i; j++) {
+                this.a.add(Queues.newConcurrentLinkedQueue());
+            }
+            // Origami end
         }
 
         @Nullable
@@ -57,7 +60,15 @@ public interface PairedQueue<T, F> {
 
         @Override
         public boolean b() {
-            return this.a.stream().allMatch(Collection::isEmpty);
+            // Origami start - remove streams
+            for (int i = 0, size = this.a.size(); i < size; ++i) {
+                Queue<Runnable> queue = this.a.get(i);
+                if (!queue.isEmpty()) {
+                    return false;
+                }
+            }
+            return true;
+            // Origami end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index 935136771..58e15989e 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -58,33 +58,38 @@ public class PathfinderGoalSelector {
     // Paper end
 
     public void a(PathfinderGoal pathfindergoal) {
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
-        this.d.removeIf((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        });
+        // Origami start - replace streams
+        for (java.util.Iterator<PathfinderGoalWrapped> it = this.d.iterator(); it.hasNext();) {
+            PathfinderGoalWrapped pathfinderGoalWrapped = it.next();
+            if (pathfinderGoalWrapped.j() == pathfindergoal) {
+                if (pathfinderGoalWrapped.g()) {
+                    pathfinderGoalWrapped.d();
+                }
+                it.remove();
+            }
+        }
+        // Origami end
     }
 
     public void doTick() {
         this.e.enter("goalCleanup");
-        this.c().filter((pathfindergoalwrapped) -> {
-            boolean flag;
-
-            if (pathfindergoalwrapped.g()) {
-                Stream stream = pathfindergoalwrapped.i().stream();
-                EnumSet enumset = this.f;
-
-                this.f.getClass();
-                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
-                    flag = false;
-                    return flag;
+        // Origami start - remove streams
+        for (java.util.Iterator<PathfinderGoalWrapped> it = this.d.iterator(); it.hasNext();) {
+            PathfinderGoalWrapped pathfinderGoalWrapped = it.next();
+            if (pathfinderGoalWrapped.g()) {
+                boolean contains = false;
+                for (PathfinderGoal.Type type : pathfinderGoalWrapped.i()) {
+                    if (this.f.contains(type)) {
+                        contains = true;
+                        break;
+                    }
+                }
+                if (contains || !pathfinderGoalWrapped.b()) {
+                    pathfinderGoalWrapped.d();
                 }
             }
-
-            flag = true;
-            return flag;
-        }).forEach(PathfinderGoal::d);
+        }
+        // Origami end
         this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
             if (!pathfindergoalwrapped.g()) {
                 this.c.remove(pathfindergoal_type);
@@ -93,30 +98,43 @@ public class PathfinderGoalSelector {
         });
         this.e.exit();
         this.e.enter("goalUpdate");
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return !pathfindergoalwrapped.g();
-        }).filter((pathfindergoalwrapped) -> {
-            Stream stream = pathfindergoalwrapped.i().stream();
-            EnumSet enumset = this.f;
-
-            this.f.getClass();
-            return stream.noneMatch(enumset::contains);
-        }).filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
-                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
-            });
-        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
-            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
-                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
-
-                pathfindergoalwrapped1.d();
-                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
-            });
-            pathfindergoalwrapped.c();
-        });
+        // Origami start - remove streams
+        UPDATE_LOOP:
+        for (java.util.Iterator<PathfinderGoalWrapped> it = this.d.iterator(); it.hasNext();) {
+            PathfinderGoalWrapped pathfinderGoalWrapped = it.next();
+            if (!pathfinderGoalWrapped.g()) {
+                for (PathfinderGoal.Type type : pathfinderGoalWrapped.i()) {
+                    if (this.f.contains(type)) {
+                        continue UPDATE_LOOP;
+                    }
+                }
+
+                for (PathfinderGoal.Type type : pathfinderGoalWrapped.i()) {
+                    if (!this.c.getOrDefault(type, PathfinderGoalSelector.b).a(pathfinderGoalWrapped)) {
+                        continue UPDATE_LOOP;
+                    }
+                }
+
+                if (pathfinderGoalWrapped.a()) {
+                    for (PathfinderGoal.Type type : pathfinderGoalWrapped.i()) {
+                        this.c.getOrDefault(type, PathfinderGoalSelector.b).d();
+                        this.c.put(type, pathfinderGoalWrapped);
+                    }
+                    pathfinderGoalWrapped.c();
+                }
+            }
+        }
+        // Origami end
         this.e.exit();
         this.e.enter("goalTick");
-        this.c().forEach(PathfinderGoalWrapped::e);
+        // Origami start - remove streams
+        for (java.util.Iterator<PathfinderGoalWrapped> it = this.d.iterator(); it.hasNext();) {
+            PathfinderGoalWrapped pathfinderGoalWrapped = it.next();
+            if (pathfinderGoalWrapped.g()) {
+                pathfinderGoalWrapped.e();
+            }
+        }
+        // Origami end
         this.e.exit();
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 4240ca81c..36fef7f70 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -443,8 +443,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition CACHED_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); // Origami - don't allocate a new BlockPosition each time
+
     protected static PathType c(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition = CACHED_BLOCKPOSITION.setValues(i, j, k); // Origami - don't allocate a new BlockPosition each time
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index c21a3ea50..05a384bc6 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -1360,7 +1360,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Spigot end
         long i = chunkcoordintpair.pair();
 
-        return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+        // Origami start - remove stream
+        if (!this.chunkDistanceManager.d(i)) {
+            return true;
+        }
+
+        for (EntityPlayer entityPlayer : this.playerMap.a.keySet()) {
+            if (playerIsInRange(entityPlayer, chunkcoordintpair, reducedRange)) {
+                return false;
+            }
+        }
+        return true;
+    }
+    //    return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+    private boolean playerIsInRange(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
             // Paper start -
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
             double blockRange = 16384.0D;
@@ -1372,7 +1385,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             return (!entityplayer.isSpectator() && a(chunkcoordintpair, (Entity) entityplayer) < blockRange); // Spigot
             // Paper end
-        });
+        //});
+        // Origami end
     }
 
     private boolean b(EntityPlayer entityplayer) {
diff --git a/src/main/java/net/minecraft/server/PlayerMap.java b/src/main/java/net/minecraft/server/PlayerMap.java
index f386c4e99..442ef443b 100644
--- a/src/main/java/net/minecraft/server/PlayerMap.java
+++ b/src/main/java/net/minecraft/server/PlayerMap.java
@@ -6,7 +6,7 @@ import java.util.stream.Stream;
 
 public final class PlayerMap {
 
-    private final Object2BooleanMap<EntityPlayer> a = new Object2BooleanOpenHashMap();
+    public final Object2BooleanMap<EntityPlayer> a = new Object2BooleanOpenHashMap(); // Origami - make public
 
     public PlayerMap() {}
 
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 4afd33a49..a71702b4d 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -377,21 +377,36 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     private static IntStream a(IInventory iinventory, EnumDirection enumdirection) {
-        return iinventory instanceof IWorldInventory ? IntStream.of(((IWorldInventory) iinventory).getSlotsForFace(enumdirection)) : IntStream.range(0, iinventory.getSize());
+        // Origami start - remove streams
+        return IntStream.of(getSlots(iinventory, enumdirection));
+    }
+
+    private static int[] getSlots(IInventory iinventory, EnumDirection enumdirection) {
+        return iinventory instanceof IWorldInventory ? ((IWorldInventory) iinventory).getSlotsForFace(enumdirection) : IntStream.range(0, iinventory.getSize()).toArray();
+        // Origami end
     }
 
     private boolean b(IInventory iinventory, EnumDirection enumdirection) {
-        return a(iinventory, enumdirection).allMatch((i) -> {
+        // Origami start - remove streams
+        for (int i : getSlots(iinventory, enumdirection)) {
             ItemStack itemstack = iinventory.getItem(i);
-
-            return itemstack.getCount() >= itemstack.getMaxStackSize();
-        });
+            if (itemstack.getCount() < itemstack.getMaxStackSize()) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     private static boolean c(IInventory iinventory, EnumDirection enumdirection) {
-        return a(iinventory, enumdirection).allMatch((i) -> {
-            return iinventory.getItem(i).isEmpty();
-        });
+        // Origami start - remove streams
+        for (int i : getSlots(iinventory, enumdirection)) {
+            if (!iinventory.getItem(i).isEmpty()) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     public static boolean a(IHopper ihopper) {
@@ -400,10 +415,18 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         if (iinventory != null) {
             EnumDirection enumdirection = EnumDirection.DOWN;
 
-            return c(iinventory, enumdirection) ? false : a(iinventory, enumdirection).anyMatch((i) -> {
+            // Origami start - remove streams
+            if (c(iinventory, enumdirection)) {
+                return false;
+            }
+            for (int i : getSlots(iinventory, enumdirection)) {
                 skipPullModeEventFire = skipHopperEvents; // Paper
-                return a(ihopper, iinventory, i, enumdirection);
-            });
+                if (a(ihopper, iinventory, i, enumdirection)) {
+                    return true;
+                }
+            }
+            return false;
+            // Origami end
         } else {
             Iterator iterator = c(ihopper).iterator();
 
diff --git a/src/main/java/net/minecraft/server/TileEntityLootable.java b/src/main/java/net/minecraft/server/TileEntityLootable.java
index d4cbce324..fa01e8ed8 100644
--- a/src/main/java/net/minecraft/server/TileEntityLootable.java
+++ b/src/main/java/net/minecraft/server/TileEntityLootable.java
@@ -72,7 +72,14 @@ public abstract class TileEntityLootable extends TileEntityContainer {
     @Override
     public boolean isEmpty() {
         this.d((EntityHuman) null);
-        return this.f().stream().allMatch(ItemStack::isEmpty);
+        // Origami start - remove streams
+        for (ItemStack itemStack : this.f()) {
+            if (!itemStack.isEmpty()) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     @Override
-- 
2.25.1.windows.1

