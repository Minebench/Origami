From 7d3e9a8d13fe5db9f16c0dfcc5d61ab3d684c295 Mon Sep 17 00:00:00 2001
From: Phoenix616 <mail@moep.tv>
Date: Thu, 30 Jan 2020 21:50:40 +0100
Subject: [PATCH] Remove some streams and object allocations

Partially based on a patch in Spottedleaf's Paper fork
---
 .../java/net/minecraft/server/Behavior.java   | 18 +++++---
 .../minecraft/server/BehaviorController.java  |  4 +-
 .../java/net/minecraft/server/ChunkMap.java   | 14 +++---
 .../minecraft/server/PathfinderNormal.java    |  4 +-
 .../net/minecraft/server/PlayerChunkMap.java  | 18 +++++++-
 .../java/net/minecraft/server/PlayerMap.java  |  2 +-
 .../minecraft/server/TileEntityHopper.java    | 45 ++++++++++++++-----
 .../minecraft/server/TileEntityLootable.java  |  9 +++-
 8 files changed, 84 insertions(+), 30 deletions(-)

diff --git a/src/main/java/net/minecraft/server/Behavior.java b/src/main/java/net/minecraft/server/Behavior.java
index f9ee7abb1..564d7fa87 100644
--- a/src/main/java/net/minecraft/server/Behavior.java
+++ b/src/main/java/net/minecraft/server/Behavior.java
@@ -38,10 +38,12 @@ public abstract class Behavior<E extends EntityLiving> {
         // Origami end
     }
 
+    public Behavior.Status getStatus() { return a();} // Origami - OBFHELPER
     public Behavior.Status a() {
         return this.b;
     }
 
+    public final void attemptStart(WorldServer worldserver, E entity, long time) { b(worldserver, entity, time); } // Origami - OBFHELPER
     public final boolean b(WorldServer worldserver, E e0, long i) {
         if (this.a(e0) && this.a(worldserver, e0)) {
             this.b = Behavior.Status.RUNNING;
@@ -61,6 +63,7 @@ public abstract class Behavior<E extends EntityLiving> {
 
     protected void a(WorldServer worldserver, E e0, long i) {}
 
+    public final void runOrStop(WorldServer worldserver, E entity, long time) { c(worldserver, entity, time); } // Origami - OBFHELPER
     public final void c(WorldServer worldserver, E e0, long i) {
         if (!this.a(i) && this.g(worldserver, e0, i)) {
             this.d(worldserver, e0, i);
@@ -72,6 +75,7 @@ public abstract class Behavior<E extends EntityLiving> {
 
     protected void d(WorldServer worldserver, E e0, long i) {}
 
+    public final void stop(WorldServer worldserver, E entity, long time) { e(worldserver, entity, time); } // Origami - OBFHELPER
     public final void e(WorldServer worldserver, E e0, long i) {
         this.b = Behavior.Status.STOPPED;
         this.f(worldserver, e0, i);
@@ -96,12 +100,14 @@ public abstract class Behavior<E extends EntityLiving> {
     }
 
     private boolean a(E e0) {
-        return this.a.entrySet().stream().allMatch((entry) -> {
-            MemoryModuleType<?> memorymoduletype = (MemoryModuleType) entry.getKey();
-            MemoryStatus memorystatus = (MemoryStatus) entry.getValue();
-
-            return e0.getBehaviorController().a(memorymoduletype, memorystatus);
-        });
+        // Origami start - remove streams
+        for (Entry<MemoryModuleType<?>, MemoryStatus> entry : this.a.entrySet()) {
+            if (!e0.getBehaviorController().a(entry.getKey(), entry.getValue())) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     public static enum Status {
diff --git a/src/main/java/net/minecraft/server/BehaviorController.java b/src/main/java/net/minecraft/server/BehaviorController.java
index c75581dd5..41136e2bb 100644
--- a/src/main/java/net/minecraft/server/BehaviorController.java
+++ b/src/main/java/net/minecraft/server/BehaviorController.java
@@ -23,11 +23,11 @@ public class BehaviorController<E extends EntityLiving> implements MinecraftSeri
 
     private final Map<MemoryModuleType<?>, Optional<?>> memories = Maps.newHashMap();
     private final Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap();
-    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap();
+    private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> c = Maps.newTreeMap(); private final Map<Integer, Map<Activity, Set<Behavior<? super E>>>> getGoals() { return c; }; // Origami - OBFHELPER
     private Schedule schedule;
     private final Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> e;
     private Set<Activity> f;
-    private final Set<Activity> g;
+    private final Set<Activity> g; private final Set<Activity> getActiveActivities() { return g; } // Origami - OBFHELPER
     private Activity h;
     private long i;
 
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e..8069e494f 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        // Origami start - remove allocation of ChunkCoordIntPair
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        // Origami end
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        // Origami start - remove allocation of ChunkCoordIntPair
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        // Origami end
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 4240ca81c..36fef7f70 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -443,8 +443,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition CACHED_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); // Origami - don't allocate a new BlockPosition each time
+
     protected static PathType c(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition = CACHED_BLOCKPOSITION.setValues(i, j, k); // Origami - don't allocate a new BlockPosition each time
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 8b2eed105..b8d83f607 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -1383,7 +1383,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Spigot end
         long i = chunkcoordintpair.pair();
 
-        return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+        // Origami start - remove stream
+        if (!this.chunkDistanceManager.d(i)) {
+            return true;
+        }
+
+        for (EntityPlayer entityPlayer : this.playerMap.a.keySet()) {
+            if (playerIsInRange(entityPlayer, chunkcoordintpair, reducedRange)) {
+                return false;
+            }
+        }
+        return true;
+    }
+    //    return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+    private boolean playerIsInRange(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
             // Paper start -
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
             double blockRange = 16384.0D;
@@ -1395,7 +1408,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             return (!entityplayer.isSpectator() && a(chunkcoordintpair, (Entity) entityplayer) < blockRange); // Spigot
             // Paper end
-        });
+        //});
+        // Origami end
     }
 
     private boolean b(EntityPlayer entityplayer) {
diff --git a/src/main/java/net/minecraft/server/PlayerMap.java b/src/main/java/net/minecraft/server/PlayerMap.java
index f386c4e99..442ef443b 100644
--- a/src/main/java/net/minecraft/server/PlayerMap.java
+++ b/src/main/java/net/minecraft/server/PlayerMap.java
@@ -6,7 +6,7 @@ import java.util.stream.Stream;
 
 public final class PlayerMap {
 
-    private final Object2BooleanMap<EntityPlayer> a = new Object2BooleanOpenHashMap();
+    public final Object2BooleanMap<EntityPlayer> a = new Object2BooleanOpenHashMap(); // Origami - make public
 
     public PlayerMap() {}
 
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 4afd33a49..a71702b4d 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -377,21 +377,36 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     private static IntStream a(IInventory iinventory, EnumDirection enumdirection) {
-        return iinventory instanceof IWorldInventory ? IntStream.of(((IWorldInventory) iinventory).getSlotsForFace(enumdirection)) : IntStream.range(0, iinventory.getSize());
+        // Origami start - remove streams
+        return IntStream.of(getSlots(iinventory, enumdirection));
+    }
+
+    private static int[] getSlots(IInventory iinventory, EnumDirection enumdirection) {
+        return iinventory instanceof IWorldInventory ? ((IWorldInventory) iinventory).getSlotsForFace(enumdirection) : IntStream.range(0, iinventory.getSize()).toArray();
+        // Origami end
     }
 
     private boolean b(IInventory iinventory, EnumDirection enumdirection) {
-        return a(iinventory, enumdirection).allMatch((i) -> {
+        // Origami start - remove streams
+        for (int i : getSlots(iinventory, enumdirection)) {
             ItemStack itemstack = iinventory.getItem(i);
-
-            return itemstack.getCount() >= itemstack.getMaxStackSize();
-        });
+            if (itemstack.getCount() < itemstack.getMaxStackSize()) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     private static boolean c(IInventory iinventory, EnumDirection enumdirection) {
-        return a(iinventory, enumdirection).allMatch((i) -> {
-            return iinventory.getItem(i).isEmpty();
-        });
+        // Origami start - remove streams
+        for (int i : getSlots(iinventory, enumdirection)) {
+            if (!iinventory.getItem(i).isEmpty()) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     public static boolean a(IHopper ihopper) {
@@ -400,10 +415,18 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         if (iinventory != null) {
             EnumDirection enumdirection = EnumDirection.DOWN;
 
-            return c(iinventory, enumdirection) ? false : a(iinventory, enumdirection).anyMatch((i) -> {
+            // Origami start - remove streams
+            if (c(iinventory, enumdirection)) {
+                return false;
+            }
+            for (int i : getSlots(iinventory, enumdirection)) {
                 skipPullModeEventFire = skipHopperEvents; // Paper
-                return a(ihopper, iinventory, i, enumdirection);
-            });
+                if (a(ihopper, iinventory, i, enumdirection)) {
+                    return true;
+                }
+            }
+            return false;
+            // Origami end
         } else {
             Iterator iterator = c(ihopper).iterator();
 
diff --git a/src/main/java/net/minecraft/server/TileEntityLootable.java b/src/main/java/net/minecraft/server/TileEntityLootable.java
index d4cbce324..fa01e8ed8 100644
--- a/src/main/java/net/minecraft/server/TileEntityLootable.java
+++ b/src/main/java/net/minecraft/server/TileEntityLootable.java
@@ -72,7 +72,14 @@ public abstract class TileEntityLootable extends TileEntityContainer {
     @Override
     public boolean isEmpty() {
         this.d((EntityHuman) null);
-        return this.f().stream().allMatch(ItemStack::isEmpty);
+        // Origami start - remove streams
+        for (ItemStack itemStack : this.f()) {
+            if (!itemStack.isEmpty()) {
+                return false;
+            }
+        }
+        return true;
+        // Origami end
     }
 
     @Override
-- 
2.25.1.windows.1

